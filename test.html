<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        #gameInfo{
            position: absolute;
            top: 0;
            right: 30px;
        }
    </style>
    <script src="MapLevel.js"></script>
    <script>
//        坦克大战地图绘制
        function drawMap() {
            let canvas1 = document.getElementById("myCanvas")
            let ctx = canvas1.getContext("2d")
            let mapImg = new Image()
            mapImg.src = "img/tankAll.gif"
            ctx.fillRect(0,0,416,416)

            for (let i = 0;i < 26; i++){
                for (let j = 0;j < 26; j++){

                    switch (map[i][j]){
                        case 0:
//                            ctx.drawImage(mapImg,0,0,16,16,16*i,16*j,16,16)
                            break
                        case 1:
                            ctx.drawImage(mapImg,0,96,16,16,16*j,16*i,16,16)
                            break
                        case 2:
                            ctx.drawImage(mapImg,16,96,16,16,16*j,16*i,16,16)
                            break
                        case 3:
                            ctx.drawImage(mapImg,32,96,16,16,16*j,16*i,16,16)
                            break
                        case 4:
                            ctx.drawImage(mapImg,48,96,16,16,16*j,16*i,16,16)
                            break
                        case 5:
                            ctx.drawImage(mapImg,64,96,16,16,16*j,16*i,16,16)
                            break
                        case 9:
                            ctx.drawImage(mapImg,256,0,32,32,16*j,16*i,32,32)
                            break
                    }
                    if (map[i][j] == 0){
//                        ctx.drawImage(mapImg,0,0,16,16,16*i,16*j,16,16)

                    }
                }
            }
        }

        let log = function (meg) {
            if (typeof meg === "string" || typeof meg === "number") {
                console.warn(meg)
            } else {
                console.log(meg)
            }
        }

        let recxX = 36
        let recxY = 0
        let recxDirectX = 1 //  运动方向，0为减，1为增
        let recxDirectY = 1
        let recxSpeed = 5
        const UP = 3
        const RIGHT = 1
        const DOWN = 0
        const LEFT = 2

        var gp = null

        function drawRect() {
            var canvas1 = document.getElementById("myCanvas")
            var ctx = canvas1.getContext("2d")
            ctx.clearRect(0,0,canvas1.width,canvas1.height)

            ctx.fillStyle = "#ccc"
            ctx.fillRect(recxX,recxY,10,10)

        }
        function rectAutoMove() {

//            if (recxDirectX && recxDirectY){
//                recxX += recxSpeed
//                recxY += recxSpeed
//            }if (recxDirectX && !recxDirectY){
//                recxX += recxSpeed
//                recxY -= recxSpeed
//            }
//
//            if (recxY >= 200){
//                recxDirectX = 1
//                recxDirectY = 0
//            }

            if(recxDirectX){
               recxX += recxSpeed
            }else {
                recxX -= recxSpeed
            }
            if (recxDirectY){
                recxY += recxSpeed
            }else {
                recxY -= recxSpeed
            }

            if (recxY >= 200){
                recxDirectY = 0
                recxDirectX = 1
            }if (recxX >= 400){
                recxDirectX = 0
//                recxDirectY = 1
            }if (recxX <= 0){
                recxDirectY = 0
                recxDirectX = 1

            }if (recxY <= 0){
                recxDirectX = 0
                recxDirectY = 1

            }
        }
        function drawCrossLine(canvasEle,length) {
    let ctx = canvasEle.getContext("2d")
    let centX = canvasEle.width/2
    let centY = canvasEle.height/2
//                log(centX - length + " " +centY)
    ctx.fillStyle = "rgba(0, 0, 200, 0.5)";
    ctx.beginPath()
    ctx.strokeStyle = "#4d5bf4"
    ctx.lineWidth = 2
    ctx.moveTo(centX - length,centY)
    ctx.lineTo(centX + length,centY)
    ctx.closePath()
    ctx.stroke()
    ctx.beginPath()
    moveTo(centX,centY - length)
    ctx.lineTo(centX,centY - length)
    ctx.lineTo(centX,centY + length)
    ctx.closePath()
    ctx.stroke()
}
        function getKeyBoardCommend(){
            window.addEventListener("keydown",function (ev) {
                switch (ev.key) {
                    case ",":
                        recxY -= recxSpeed
                        break
                    case "o":
                        recxY += recxSpeed
                        break
                    case "a":
                        recxX -= recxSpeed

                        break
                    case "e":
                        recxX += recxSpeed
                        break
                }

            }.bind(this),false)
        }
        function isButtonPressed(b) {
            if (typeof(b) == "object") {
                return b.pressed;
            }
            return b == 1.0;
        }
        var rAF = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.requestAnimationFrame;
        function getControlCommend() {
                if (gp){
                    if (isButtonPressed(gp.buttons[LEFT])){
                        recxX -= recxSpeed
                    }if (isButtonPressed(gp.buttons[UP])){
                        recxY -= recxSpeed
                    }if (isButtonPressed(gp.buttons[RIGHT])){
                        recxX += recxSpeed
                    }if (isButtonPressed(gp.buttons[DOWN])){
                        recxY += recxSpeed
                    }

                    //                    log(gp.axes[0].toFixed(2))
//            左边摇杆
                    // gp.axes[0] 1 => 右方向， -1 => 左方向
                    // gp.axes[1] 1 => 下方向

//            右边摇杆
                    // gp.axes[2] 1 => 右方向
                    // gp.axes[3] 1 => 下方向

                    //  gp.axes[0] 是形如 0.07541123691518906 极长的数字 .toFixed(2) 保留到两位
                    if (gp.axes[0].toFixed(2) >= 0.3){
                        recxX += recxSpeed
                    }if (gp.axes[0].toFixed(2) <= -0.3){
                        recxX -= recxSpeed
                    }if (gp.axes[1].toFixed(2) >= 0.3){
                        recxY += recxSpeed
                    }if (gp.axes[1].toFixed(2) <= -0.3){
                        recxY -= recxSpeed
                    }




                }
        }

        // 新游戏地图绘制
        function drawRPGMap() {
            let canvas1 = document.getElementById("myCanvas")
            let ctx = canvas1.getContext("2d")
            let mapImg = new Image()
            let mapImg1 = new Image()
            let mapImg2 = new Image()
            let mapImg3 = new Image()
//            mapImg.src = "img/tankAll.gif"
            ctx.fillRect(0,0,416,416)


            let r = 3
            let rr = "img/tankAll"+r+".gif"
            log(rr)

            for (let i = 0;i < 26; i++){
                for (let j = 0;j < 26; j++){

                    switch (map[i][j]){
                        case 0:
                            mapImg.src = "img/rpgImgs/0.png"
                            ctx.drawImage(mapImg,48*j,64*i,48,64)
                            break
                        case 1:
                            mapImg1.src = "img/rpgImgs/1.png"

                            ctx.drawImage(mapImg1,48*j,64*i,48,64)
                            break
                        case 2:
                            mapImg2.setAttribute("src","img/rpgImgs/2.png")
                            ctx.drawImage(mapImg2,48*j,64*i,48,64)
                            break
                        case 3:
                            mapImg3.src = "img/rpgImgs/3.png"
log(mapImg3)
                            ctx.drawImage(mapImg3,48*j,64*i,48,64)
                            break
//                        case 4:
//                            ctx.drawImage(mapImg,48,96,16,16,16*j,16*i,16,16)
//                            break
//                        case 5:
//                            ctx.drawImage(mapImg,64,96,16,16,16*j,16*i,16,16)
//                            break
//                        case 9:
//                            ctx.drawImage(mapImg,256,0,32,32,16*j,16*i,32,32)
//                            break
                    }
                    if (map[i][j] == 0){
//                        ctx.drawImage(mapImg,0,0,16,16,16*i,16*j,16,16)

                    }
                }
            }


        }



        window.onload = function () {
//            drawRPGMap()
//            drawMap()

            let gamepadinfo = document.getElementById("gamepadinfo")
            let oBtnPause = document.getElementById("oBtnPause")
            let oBtnRestart = document.getElementById("oBtnRestart")
            var canvas1 = document.getElementById("myCanvas")
            var ctx = canvas1.getContext("2d")


            var fps = 30;
            var pause = false;
            var now;
            var then = Date.now();
            var interval = 1000/fps;
            var delta;
            let framID = 0
            window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

            oBtnPause.addEventListener("click",function () {
                pause = true
                tick()
            })
            oBtnRestart.addEventListener("click",function () {
                pause = false
                tick()
            })

            window.addEventListener("gamepadconnected", function (e) {
                gp = navigator.getGamepads()[e.gamepad.index];
                /**
                 * gp           即是一个 Gamepad 对象
                 * gp.mapping   返回空字符串表示没有映射是用这个手柄
                 *              返回 standard 游戏手柄的控制已被映射到标准键盘布局。目前唯一已知的映射是“standard”
                 * axes         摇杆，[-1.0 .. 1.0]
                 */
//                log(gp)
                console.log("Gamepad 已连接 at index %d: %s. %d buttons, %d axes, %s 映射, %s  timestamp",
                    gp.index, gp.id,
                    gp.buttons.length, gp.axes.length,gp.mapping,gp.timestamp);

            });
            window.addEventListener("gamepaddisconnected", function(e) {
                console.error("Gamepad 已断开连接 from index %d: %s",
                    e.gamepad.index, e.gamepad.id);
            });
            function tick() {
                if(pause)
                    return;
                if(window.requestAnimationFrame) {

                    now = Date.now();
                    delta = now - then;
                    if (delta > interval) {
                        // 这里不能简单then=now，否则还会出现上边简单做法的细微时间差问题。例如fps=10，每帧100ms，而现在每16ms（60fps）执行一次draw。16*7=112>100，需要7次才实际绘制一次。这个情况下，实际10帧需要112*10=1120ms>1000ms才绘制完成。
                        then = now - (delta % interval);
                        gameLoop()
                        // ... Code for Drawing the Frame ...

                    }
                    framID = requestAnimationFrame(tick);
                }
            }
            function _main() {
                tick();
                getKeyBoardCommend()
            }
            function gameLoop(){
//                rectAutoMove()
                drawRect();
                drawCrossLine(canvas1,50)
//                getControlCommend()
//                controlRect()
                getControlCommend()
            }

            _main()

        }

    </script>
</head>
<body>
<!--Created by Enzo on 2017/8/21.-->

<canvas id="myCanvas" width="1400px" height="2000px" style="border: 1px solid #4cae4c"></canvas>
<div id="gameInfo">
    <input type="button"  id="oBtnPause"  value="Pause">
    <input type="button"  id="oBtnRestart"  value="Restart">
</div>

<div>
    <h3 id="gamepadinfo">connecting</h3>
</div>
</body>
</html>